정렬 알고리즘
===========

**평균적으로 O(N^2)의 시간 복잡도를 가지는 정렬 알고리즘**

- 선택 정렬
    
    현재 정렬되지 않은 데이터 중에서 가장 작은 데이터를 선택하여 가장 왼쪽의 데이터와 
    
    바꿉니다. 맨 왼쪽 데이터를 제외한 데이터에 대해서 선택 정렬을 반복합니다.
    
</br>

- 버블 정렬
    
    서로 인접한 두 원소를 검사하는 알고리즘입니다.
    
    1회전이 끝나면 가장 큰 원소가 맨 뒤로 이동하여 제외됩니다.
    
</br>

- 삽입 정렬
    
    정렬 범위를 한 칸씩 확장해나가면서 새로운 값을 올바른 위치에 찾아 삽입하는 
    
    방식입니다.
    
    두 번째 원소부터 시작하여 마지막 원소의 자리까지 찾습니다.
    
    자리를 찾으면 삽입을 위해 원소를 한 칸씩 뒤로 이동시켜야 합니다.
    
</br>

**평균적으로 O(N)의 시간 복잡도를 갖는 정렬 알고리즘**

- 계수 정렬
    
    계수 정렬은 중복된 값이 많이 분포되어 있는 배열을 정렬할 때 효과적인 
    
    정렬 알고리즘입니다.
    
    데이터의 값이 양의 정수인 경우에만 사용 가능하지만 매우 빠른 성능을 자랑합니다.
    
</br>    
    
- 기수 정렬
    
    기수 정렬은 낮은 자리수부터 비교하여 정렬해 가는 정렬 알고리즘입니다.
    
    원소들의 값이 음수가 아닌 정수이고 자릿수가 모두 같을 때 사용 가능합니다.
    
</br>

**평균적으로 O(NlogN)의 시간 복잡도를 가지는 정렬 알고리즘**

- 병합 정렬
    
    분할 정복(Divide and Conquer) 기법과 재귀를 이용한 정렬입니다.
    
    주어진 배열을 원소가 하나만 남을 때까지 계속 반으로 나눈 후, 크기 순으로 정렬을 하면서 다시 병합합니다.
    
</br>

- 퀵 정렬
    
    **분할 정복(Divide and Conquer) 기법**과 **재귀**를 이용한 
    
    정렬 알고리즘입니다. 
    
    리스트의 요소 중 하나를 pivot 이라고 하는 임의의 기준값으로 사용합니다.
    
    pivot을 기준으로 작은 원소들은 왼쪽 리스트, 큰 원소들은 오른쪽 리스트로 옮기고 각각을 다시 퀵 정렬하는 것을 반복합니다.
    

